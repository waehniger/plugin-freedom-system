<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sektor - Granular Sampler</title>
    <style>
        /* ====================================================================
           CRITICAL CSS CONSTRAINTS
           ==================================================================== */

        /* CRITICAL: Use 100%, NOT 100vh (JUCE WebView constraint) */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            box-sizing: border-box;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* ====================================================================
           NATIVE APPLICATION FEEL
           ==================================================================== */

        body {
            /* Disable text selection */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;

            /* Disable touch callouts */
            -webkit-touch-callout: none;

            /* Default cursor */
            cursor: default;

            /* Disable tap highlight */
            -webkit-tap-highlight-color: transparent;

            /* Plugin styling */
            background: #2a2a2a;
            color: #ffffff;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        /* ====================================================================
           LAYOUT STRUCTURE
           ==================================================================== */

        .plugin-container {
            width: 900px;
            height: 600px;
            display: flex;
            flex-direction: column;
        }

        /* Header - 60px */
        .header {
            height: 60px;
            background: #1a1a1a;
            display: flex;
            align-items: center;
            padding: 0 30px;
            gap: 20px;
            border-bottom: 1px solid #333;
        }

        .drop-zone {
            flex: 1;
            height: 40px;
            background: #2a2a2a;
            border: 2px dashed #666666;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #999999;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .drop-zone:hover {
            border-color: #ff8c00;
            color: #ff8c00;
            background: #333;
        }

        .browse-button {
            padding: 10px 20px;
            background: #404040;
            border: none;
            border-radius: 4px;
            color: #ffffff;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .browse-button:hover {
            background: #505050;
        }

        .plugin-title {
            font-size: 24px;
            font-weight: 700;
            color: #ff8c00;
            letter-spacing: 0.05em;
            margin-left: auto;
        }

        /* Waveform Display - 360px */
        .waveform-container {
            height: 360px;
            background: #2a2a2a;
            padding: 30px;
            position: relative;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            border-radius: 4px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666666;
            font-size: 14px;
        }

        /* Controls - 180px */
        .controls-container {
            height: 180px;
            background: #2a2a2a;
            padding: 20px 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .controls-row {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .control {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-label {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #999999;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            flex: 1;
            height: 6px;
            background: #404040;
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #ff8c00;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #ffa033;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #ff8c00;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #ffa033;
        }

        .slider-value {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            min-width: 70px;
            text-align: right;
        }

        .info-row {
            display: flex;
            gap: 40px;
            align-items: center;
            padding-top: 5px;
            border-top: 1px solid #333;
        }

        /* Region Tab Buttons */
        .region-tabs {
            display: flex;
            gap: 4px;
            margin-right: 20px;
        }

        .region-tab {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .region-tab.selected {
            box-shadow: 0 0 0 2px #fff;
        }

        .region-tab.inactive {
            opacity: 0.4;
        }

        /* Region colors */
        .region-tab[data-region="0"] { background: #ff8c00; color: #1a1a1a; }
        .region-tab[data-region="1"] { background: #4a9eff; color: #1a1a1a; }
        .region-tab[data-region="2"] { background: #4aff7f; color: #1a1a1a; }
        .region-tab[data-region="3"] { background: #c44aff; color: #1a1a1a; }
        .region-tab[data-region="4"] { background: #4afff0; color: #1a1a1a; }

        .toggle-button {
            padding: 8px 16px;
            background: #404040;
            border: none;
            border-radius: 4px;
            color: #ffffff;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .toggle-button.active {
            background: #ff8c00;
            color: #1a1a1a;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: #999999;
        }

        .info-value {
            font-weight: 600;
            color: #ffffff;
        }

        /* ====================================================================
           DEBUG PANEL (Collapsible)
           ==================================================================== */

        .debug-panel {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 350px;
            max-height: 250px;
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
        }

        .debug-header {
            background: #ff8c00;
            color: #1a1a1a;
            padding: 8px 12px;
            font-weight: 700;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .debug-header:hover {
            background: #ffa033;
        }

        .debug-toggle {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .debug-logs {
            flex: 1;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.3;
            color: #00ff00;
            background: #0a0a0a;
            padding: 8px;
            display: none;
        }

        .debug-logs.open {
            display: block;
        }

        .debug-logs::-webkit-scrollbar {
            width: 6px;
        }

        .debug-logs::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .debug-logs::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }

        .debug-logs::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        .debug-log-entry {
            margin-bottom: 2px;
            word-break: break-word;
        }

        .debug-log-entry.error {
            color: #ff6b6b;
        }

        .debug-log-entry.warning {
            color: #ffd93d;
        }

        .debug-log-entry.success {
            color: #6bcf7f;
        }

        .debug-log-entry.info {
            color: #4dabf7;
        }

        .debug-clear-btn {
            position: absolute;
            right: 30px;
            top: 8px;
            background: none;
            border: none;
            color: #1a1a1a;
            cursor: pointer;
            font-size: 12px;
            font-weight: 700;
            padding: 0;
        }

        .debug-clear-btn:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <!-- DEBUG PANEL (Bottom-Right Corner) -->
    <div class="debug-panel">
        <div class="debug-header">
            <span>üêõ DEBUG</span>
            <button class="debug-clear-btn" id="debugClearBtn">CLEAR</button>
            <div class="debug-toggle" id="debugToggle">‚ñº</div>
        </div>
        <div class="debug-logs" id="debugLogs"></div>
    </div>

    <div class="plugin-container">
        <!-- Header Section -->
        <div class="header">
            <div class="drop-zone" id="dropZone">
                Drop Sample Here or Click to Browse
            </div>
            <button class="browse-button" id="browseButton">Browse...</button>
            <div class="plugin-title">SEKTOR</div>
        </div>

        <!-- Waveform Display Section -->
        <div class="waveform-container">
            <canvas id="waveformCanvas" style="width: 100%; height: 100%;"></canvas>
        </div>

        <!-- Controls Section -->
        <div class="controls-container">
            <!-- First Row: Grain Size, Density, Pitch Shift, Spacing -->
            <div class="controls-row">
                <div class="control">
                    <div class="control-label">Grain Size</div>
                    <div class="slider-container">
                        <input type="range" id="GRAIN_SIZE" min="0" max="1" step="0.001" value="0.184">
                        <div class="slider-value" id="grainSizeValue">100.0 ms</div>
                    </div>
                </div>

                <div class="control">
                    <div class="control-label">Density</div>
                    <div class="slider-container">
                        <input type="range" id="DENSITY" min="0" max="1" step="0.001" value="0.246">
                        <div class="slider-value" id="densityValue">50.0 g/s</div>
                    </div>
                </div>

                <div class="control">
                    <div class="control-label">Pitch Shift</div>
                    <div class="slider-container">
                        <input type="range" id="PITCH_SHIFT" min="0" max="1" step="0.001" value="0.5">
                        <div class="slider-value" id="pitchShiftValue">0.0 st</div>
                    </div>
                </div>

                <div class="control">
                    <div class="control-label">Spacing</div>
                    <div class="slider-container">
                        <input type="range" id="SPACING" min="0" max="1" step="0.001" value="0.474">
                        <div class="slider-value" id="spacingValue">1.00</div>
                    </div>
                </div>
            </div>

            <!-- Second Row: Region Tabs, Polyphony toggle and status info -->
            <div class="info-row">
                <div class="region-tabs">
                    <button class="region-tab selected" data-region="0">1</button>
                    <button class="region-tab inactive" data-region="1">2</button>
                    <button class="region-tab inactive" data-region="2">3</button>
                    <button class="region-tab inactive" data-region="3">4</button>
                    <button class="region-tab inactive" data-region="4">5</button>
                </div>
                <button class="toggle-button active" id="polyphonyToggle">Poly</button>
                <div class="info-item">
                    <span>Sample:</span>
                    <span class="info-value" id="sampleInfo">No sample loaded</span>
                </div>
                <div class="info-item">
                    <span>Status:</span>
                    <span class="info-value" id="status">Ready</span>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript Module -->
    <script type="module">
        import { getNativeFunction, getSliderState, getToggleState } from './js/juce/index.js';

        // Get native functions from C++
        const nativeOpenBrowser = getNativeFunction("nativeOpenBrowser");
        const nativeFileDrop = getNativeFunction("nativeFileDrop");

        // =========================================================
        // MULTI-REGION STATE (5 regions)
        // =========================================================
        const NUM_REGIONS = 5;
        const REGION_COLORS = [
            '#ff8c00',  // Region 0: Orange
            '#4a9eff',  // Region 1: Blue
            '#4aff7f',  // Region 2: Green
            '#c44aff',  // Region 3: Purple
            '#4afff0'   // Region 4: Cyan
        ];

        // Region data structure
        const regions = [];
        let selectedRegionIndex = 0;

        // Initialize all regions from C++ parameters
        for (let i = 0; i < NUM_REGIONS; i++) {
            const startState = getSliderState(`REGION_START_${i}`);
            const endState = getSliderState(`REGION_END_${i}`);
            const activeState = getToggleState(`REGION_ACTIVE_${i}`);

            if (!startState || !endState || !activeState) {
                console.error(`[Sektor] Failed to get region ${i} state from JUCE`);
                continue;
            }

            const region = {
                index: i,
                startState: startState,
                endState: endState,
                activeState: activeState,
                start: startState.getNormalisedValue(),
                end: endState.getNormalisedValue(),
                active: activeState.getValue(),
                color: REGION_COLORS[i]
            };

            // Listen for parameter changes from C++ (automation/preset load)
            startState.valueChangedEvent.addListener(() => {
                region.start = startState.getNormalisedValue();
                requestRender();
            });

            endState.valueChangedEvent.addListener(() => {
                region.end = endState.getNormalisedValue();
                requestRender();
            });

            activeState.valueChangedEvent.addListener(() => {
                region.active = activeState.getValue();
                updateRegionTabUI();
                requestRender();
            });

            regions.push(region);
            console.log(`[Sektor] Region ${i+1} initialized: ${region.start.toFixed(3)} - ${region.end.toFixed(3)}, active: ${region.active}`);
        }

        // Update region tab UI to reflect active states
        function updateRegionTabUI() {
            const tabs = document.querySelectorAll('.region-tab');
            tabs.forEach((tab, idx) => {
                if (idx < regions.length) {
                    const isActive = regions[idx].active;
                    const isSelected = idx === selectedRegionIndex;
                    tab.classList.toggle('inactive', !isActive);
                    tab.classList.toggle('selected', isSelected);
                }
            });
        }

        // Initialize tab click handlers
        const regionTabs = document.querySelectorAll('.region-tab');
        regionTabs.forEach((tab) => {
            const regionIndex = parseInt(tab.dataset.region);

            // Left-click: Select region for editing
            tab.addEventListener('click', (e) => {
                if (e.shiftKey) {
                    // Shift+Click: Toggle active state
                    const region = regions[regionIndex];
                    if (region) {
                        region.active = !region.active;
                        region.activeState.setValue(region.active);
                        updateRegionTabUI();
                        requestRender();
                    }
                } else {
                    // Normal click: Select for editing
                    selectedRegionIndex = regionIndex;
                    updateRegionTabUI();
                    requestRender();
                    console.log(`[Sektor] Selected region ${regionIndex + 1} for editing`);
                }
            });

            // Right-click: Toggle active state (alternative)
            tab.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const region = regions[regionIndex];
                if (region) {
                    region.active = !region.active;
                    region.activeState.setValue(region.active);
                    updateRegionTabUI();
                    requestRender();
                    console.log(`[Sektor] Region ${regionIndex + 1} active: ${region.active}`);
                }
            });
        });

        // Initialize UI
        updateRegionTabUI();
        console.log('[Sektor] Multi-region system initialized with', regions.length, 'regions');

        // ====================================================================
        // DEBUG PANEL SETUP
        // ====================================================================
        const debugPanel = {
            logs: [],
            maxLogs: 100,

            addLog(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = { timestamp, message, type };
                this.logs.push(logEntry);

                // Keep only last 100 logs
                if (this.logs.length > this.maxLogs) {
                    this.logs.shift();
                }

                this.render();
            },

            render() {
                const debugLogs = document.getElementById('debugLogs');
                if (!debugLogs) return;

                debugLogs.innerHTML = this.logs
                    .map(log => `<div class="debug-log-entry ${log.type}">[${log.timestamp}] ${log.message}</div>`)
                    .join('');

                // Auto-scroll to bottom
                debugLogs.scrollTop = debugLogs.scrollHeight;
            },

            clear() {
                this.logs = [];
                this.render();
            }
        };

        // Intercept console.log
        const originalLog = console.log;
        console.log = function(...args) {
            originalLog.apply(console, args);
            const message = args.map(arg =>
                typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
            ).join(' ');
            debugPanel.addLog(message, 'info');
        };

        // Intercept console.error
        const originalError = console.error;
        console.error = function(...args) {
            originalError.apply(console, args);
            const message = args.map(arg =>
                typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
            ).join(' ');
            debugPanel.addLog(message, 'error');
        };

        // Intercept console.warn
        const originalWarn = console.warn;
        console.warn = function(...args) {
            originalWarn.apply(console, args);
            const message = args.map(arg =>
                typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
            ).join(' ');
            debugPanel.addLog(message, 'warning');
        };

        // Debug Panel UI Controls
        const debugHeader = document.querySelector('.debug-header');
        const debugLogs = document.getElementById('debugLogs');
        const debugToggle = document.getElementById('debugToggle');
        const debugClearBtn = document.getElementById('debugClearBtn');

        if (debugHeader && debugLogs) {
            debugHeader.addEventListener('click', () => {
                debugLogs.classList.toggle('open');
                debugToggle.textContent = debugLogs.classList.contains('open') ? '‚ñ≤' : '‚ñº';
            });

            debugClearBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                debugPanel.clear();
            });
        }

        console.log('[Sektor Phase 3.2] Initializing parameter bindings...');

        // Parameter bindings (4 primary granular parameters)
        const parameters = [
            {
                id: 'GRAIN_SIZE',
                min: 10.0,
                max: 500.0,
                unit: 'ms',
                decimals: 1,
                valueElement: 'grainSizeValue'
            },
            {
                id: 'DENSITY',
                min: 1.0,
                max: 200.0,
                unit: 'g/s',
                decimals: 1,
                valueElement: 'densityValue'
            },
            {
                id: 'PITCH_SHIFT',
                min: -12.0,
                max: 12.0,
                unit: 'st',
                decimals: 1,
                valueElement: 'pitchShiftValue'
            },
            {
                id: 'SPACING',
                min: 0.1,
                max: 2.0,
                unit: '',
                decimals: 2,
                valueElement: 'spacingValue'
            }
        ];

        // Bind each parameter
        parameters.forEach(param => {
            const slider = document.getElementById(param.id);
            const valueDisplay = document.getElementById(param.valueElement);

            if (!slider || !valueDisplay) {
                console.error(`[Sektor] Missing DOM element for ${param.id}`);
                return;
            }

            // Get slider state from JUCE
            const sliderState = getSliderState(param.id);

            if (!sliderState) {
                console.error(`[Sektor] Failed to get slider state for ${param.id}`);
                return;
            }

            // Helper: denormalize value
            const denormalize = (normalized) => {
                return param.min + normalized * (param.max - param.min);
            };

            // Helper: format value for display
            const formatValue = (value) => {
                const formatted = value.toFixed(param.decimals);
                return param.unit ? `${formatted} ${param.unit}` : formatted;
            };

            // Initialize slider with current value from JUCE
            const initialValue = sliderState.getNormalisedValue();
            slider.value = initialValue;
            valueDisplay.textContent = formatValue(denormalize(initialValue));

            console.log(`[Sektor] Bound ${param.id}: ${denormalize(initialValue).toFixed(param.decimals)} ${param.unit}`);

            // Update JUCE when slider changes
            slider.addEventListener('input', (e) => {
                const normalized = parseFloat(e.target.value);
                sliderState.setNormalisedValue(normalized);
                valueDisplay.textContent = formatValue(denormalize(normalized));
            });

            // Update slider when JUCE changes (automation, preset load - Pattern #15)
            sliderState.valueChangedEvent.addListener(() => {
                const normalized = sliderState.getNormalisedValue();
                slider.value = normalized;
                valueDisplay.textContent = formatValue(denormalize(normalized));
            });
        });

        // Polyphony mode toggle (Pattern #19: Use getToggleState for boolean parameters)
        const polyphonyToggle = document.getElementById('polyphonyToggle');
        const polyphonyState = getToggleState('POLYPHONY_MODE');

        if (polyphonyToggle && polyphonyState) {
            // Initialize UI with current state
            const initialState = polyphonyState.getValue();
            polyphonyToggle.textContent = initialState ? 'Poly' : 'Mono';
            polyphonyToggle.classList.toggle('active', initialState);

            // Toggle on click
            polyphonyToggle.addEventListener('click', () => {
                const currentValue = polyphonyState.getValue();
                polyphonyState.setValue(!currentValue);
                polyphonyToggle.textContent = !currentValue ? 'Poly' : 'Mono';
                polyphonyToggle.classList.toggle('active', !currentValue);
            });

            // Update when JUCE changes (Pattern #15: no callback parameters)
            polyphonyState.valueChangedEvent.addListener(() => {
                const value = polyphonyState.getValue();
                polyphonyToggle.textContent = value ? 'Poly' : 'Mono';
                polyphonyToggle.classList.toggle('active', value);
            });

            console.log('[Sektor] Bound POLYPHONY_MODE:', initialState ? 'Poly' : 'Mono');
        } else {
            console.error('[Sektor] Failed to bind polyphony toggle');
        }

        // =========================================================
        // FILE HANDLERS
        // =========================================================
        const dropZone = document.getElementById('dropZone');
        const browseButton = document.getElementById('browseButton');

        // 1. Browse button: Call native C++ function
        if (browseButton) {
            browseButton.addEventListener('click', () => {
                console.log('[JS] Requesting native file browser...');
                nativeOpenBrowser();  // Calls C++ to open native dialog
            });
        }

        // 2. Drag & drop zone: Read file and send Base64 data
        if (dropZone) {
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();  // CRITICAL: Allows drop
                e.stopPropagation();
                dropZone.style.borderColor = '#ff8c00';
                dropZone.style.background = '#333';
            });

            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.style.borderColor = '#666666';
                dropZone.style.background = '#2a2a2a';
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.style.borderColor = '#666666';
                dropZone.style.background = '#2a2a2a';

                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    console.log('[JS] File dropped:', file.name);

                    // Read file in browser using FileReader
                    const reader = new FileReader();

                    reader.onload = function(event) {
                        const base64String = event.target.result;  // Includes "data:audio/wav;base64,..." header
                        console.log('[JS] Sending', base64String.length, 'bytes to C++');

                        window.updateStatus("Uploading to engine...");

                        // Send filename and Base64 data to C++
                        nativeFileDrop(file.name, base64String).then(() => {
                            console.log("[JS] Transfer complete");
                        }).catch((error) => {
                            console.error("[JS] Transfer failed:", error);
                            window.updateStatus("Error: Upload failed");
                        });
                    };

                    reader.onerror = function() {
                        console.error("[JS] Failed to read file");
                        window.updateStatus("Error: Could not read file");
                    };

                    // Read file as Base64 data URL
                    reader.readAsDataURL(file);
                }
            });

            // Drop zone click: Also trigger native file browser
            dropZone.addEventListener('click', () => {
                console.log('[JS] Drop zone clicked, opening native file dialog...');
                nativeOpenBrowser();
            });
        }

        // Status update function (called from C++)
        window.updateStatus = (message) => {
            const statusElement = document.getElementById('status');
            if (statusElement) {
                statusElement.textContent = message;
                console.log('[Sektor] Status:', message);
            }

            // Update sample info if filename detected
            if (message.includes('Sample loaded:')) {
                const filename = message.replace('Sample loaded: ', '');
                const sampleInfo = document.getElementById('sampleInfo');
                if (sampleInfo) {
                    sampleInfo.textContent = filename;
                }
            } else if (message.includes('Loading')) {
                const sampleInfo = document.getElementById('sampleInfo');
                if (sampleInfo) {
                    sampleInfo.textContent = 'Loading...';
                }
            } else if (message.includes('Error')) {
                const sampleInfo = document.getElementById('sampleInfo');
                if (sampleInfo) {
                    sampleInfo.textContent = 'Load failed';
                }
            }
        };

        // =========================================================
        // WAVEFORM VISUALIZATION
        // =========================================================

        const canvas = document.getElementById('waveformCanvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        let currentWaveformData = [];

        // Resize canvas for high-DPI displays
        function resizeCanvas() {
            if (!canvas) return;
            const container = canvas.parentElement;
            canvas.width = container.clientWidth * window.devicePixelRatio;
            canvas.height = container.clientHeight * window.devicePixelRatio;
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            drawWaveform(currentWaveformData);
        });
        resizeCanvas();

        // =========================================================
        // MOUSE INTERACTION FOR REGION SELECTION
        // =========================================================
        let isDragging = false;
        let dragStartX = 0;

        // Helper function to update selected region bounds
        function updateRegion(start, end) {
            // Enforce minimum region size (0.1%)
            if (end - start < 0.001) end = start + 0.001;

            const region = regions[selectedRegionIndex];
            if (!region) return;

            region.start = start;
            region.end = end;

            // Send to C++
            region.startState.setNormalisedValue(start);
            region.endState.setNormalisedValue(end);

            requestRender();
        }

        // Helper function to request smooth rendering
        function requestRender() {
            window.requestAnimationFrame(() => {
                drawWaveform(currentWaveformData);
            });
        }

        // Mouse event handlers for canvas
        if (canvas) {
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const normalizedX = Math.max(0, Math.min(1, x / rect.width));

                dragStartX = normalizedX;
                updateRegion(normalizedX, normalizedX);
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const currentX = Math.max(0, Math.min(1, x / rect.width));

                // Calculate start and end (direction-agnostic)
                const start = Math.min(dragStartX, currentX);
                const end = Math.max(dragStartX, currentX);

                updateRegion(start, end);
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        // Called by C++ via evaluateJavascript
        window.updateWaveform = (peaks) => {
            console.log('[JS] Received waveform data, points:', peaks.length);
            currentWaveformData = peaks;
            requestRender();  // Use requestAnimationFrame for smoother rendering
        };

        function drawWaveform(peaks) {
            if (!canvas || !ctx || !peaks || peaks.length === 0) return;

            const width = canvas.width;
            const height = canvas.height;
            const centerY = height / 2;

            // 1. Clear canvas
            ctx.clearRect(0, 0, width, height);

            // 2. Draw waveform (base color - gray when regions active)
            ctx.fillStyle = '#555555';
            ctx.beginPath();
            ctx.moveTo(0, centerY);

            const barWidth = width / peaks.length;

            // Top path
            for (let i = 0; i < peaks.length; i++) {
                const x = i * barWidth;
                const amplitude = peaks[i] * (height * 0.9) / 2;
                ctx.lineTo(x, centerY - amplitude);
            }

            // Bottom path (reversed)
            for (let i = peaks.length - 1; i >= 0; i--) {
                const x = i * barWidth;
                const amplitude = peaks[i] * (height * 0.9) / 2;
                ctx.lineTo(x, centerY + amplitude);
            }

            ctx.closePath();
            ctx.fill();

            // 3. Draw ALL active regions (back to front, selected last)
            const activeRegions = regions.filter(r => r.active);
            const sortedRegions = [...activeRegions].sort((a, b) => {
                // Selected region draws last (on top)
                if (a.index === selectedRegionIndex) return 1;
                if (b.index === selectedRegionIndex) return -1;
                return a.index - b.index;
            });

            sortedRegions.forEach(region => {
                const isSelected = region.index === selectedRegionIndex;
                const startX = region.start * width;
                const endX = region.end * width;
                const regionWidth = endX - startX;

                // Draw colored region overlay
                ctx.save();

                // Clip to region bounds
                ctx.beginPath();
                ctx.rect(startX, 0, regionWidth, height);
                ctx.clip();

                // Draw colored waveform in this region
                const alpha = isSelected ? 1.0 : 0.5;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = region.color;
                ctx.beginPath();
                ctx.moveTo(0, centerY);

                // Top path
                for (let i = 0; i < peaks.length; i++) {
                    const x = i * barWidth;
                    const amplitude = peaks[i] * (height * 0.9) / 2;
                    ctx.lineTo(x, centerY - amplitude);
                }

                // Bottom path (reversed)
                for (let i = peaks.length - 1; i >= 0; i--) {
                    const x = i * barWidth;
                    const amplitude = peaks[i] * (height * 0.9) / 2;
                    ctx.lineTo(x, centerY + amplitude);
                }

                ctx.closePath();
                ctx.fill();

                ctx.restore();

                // Draw region boundary lines
                ctx.strokeStyle = region.color;
                ctx.lineWidth = isSelected ? 3 : 1;
                ctx.globalAlpha = isSelected ? 1.0 : 0.6;

                // Start line
                ctx.beginPath();
                ctx.moveTo(startX, 0);
                ctx.lineTo(startX, height);
                ctx.stroke();

                // End line
                ctx.beginPath();
                ctx.moveTo(endX, 0);
                ctx.lineTo(endX, height);
                ctx.stroke();

                ctx.globalAlpha = 1.0;
            });

            // 4. Draw region index labels
            sortedRegions.forEach(region => {
                const isSelected = region.index === selectedRegionIndex;
                const startX = region.start * width;

                ctx.font = `bold ${isSelected ? 14 : 11}px sans-serif`;
                ctx.fillStyle = region.color;
                ctx.textBaseline = 'top';
                ctx.fillText(`${region.index + 1}`, startX + 5, 5);
            });

            // 5. Center line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
        }

        console.log('[Sektor Phase 3.3] Waveform visualization initialized');
        console.log('[Sektor Phase 3.2] Initialization complete');
    </script>
</body>
</html>
