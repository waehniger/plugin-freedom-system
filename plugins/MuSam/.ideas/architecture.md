# DSP Architecture: MuSam

**CRITICAL CONTRACT:** This specification is immutable during Stages 1-4 implementation. Stage 1 Planning cannot proceed without this file. Stage 3 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research
**Referenced by:** Stage 1 (Planning), Stage 3 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Sample Loader
- **JUCE Class:** `juce::AudioFormatManager`, `juce::AudioFormatReader`
- **Purpose:** Load audio files (WAV/AIFF/MP3) and store in memory for playback
- **Parameters Affected:** None (triggered via UI drag-drop)
- **Configuration:**
  - Supports WAV, AIFF, MP3 formats (via system codecs)
  - Loads entire sample into `juce::AudioBuffer<float>` memory
  - Background thread loading (non-blocking)
  - Default region distribution: 5 equal slices (0-20%, 20-40%, 40-60%, 60-80%, 80-100%)

### Region Playback Engine
- **JUCE Class:** Custom implementation (sample position tracking)
- **Purpose:** Playback specific regions of loaded sample with variable rate
- **Parameters Affected:** `speed` (global), `region_N_start`, `region_N_end` (per region)
- **Configuration:**
  - 5 independent playback engines (one per region)
  - Variable-rate playback: `playbackRate = speed * (1.0 + pitchShiftRatio)`
  - Region boundaries: Start/End positions in sample (0-100% mapped to sample length)
  - Speed parameter affects both tempo and pitch (tape-style)

### Pitch Shifter
- **JUCE Class:** Custom implementation (granular synthesis approach)
- **Purpose:** Shift pitch of region playback without changing tempo
- **Parameters Affected:** `region_N_pitch` (per region, -24 to +24 semitones)
- **Configuration:**
  - Granular synthesis approach (simpler than phase vocoder, acceptable quality)
  - Grain size: 1024 samples (~21ms @ 48kHz)
  - Overlap: 50% (512 samples)
  - Pitch ratio: `2^(pitchSemitones / 12.0)`
  - Alternative: `juce::dsp::PitchShifter` if available (research needed)

### Lowpass Filter
- **JUCE Class:** `juce::dsp::IIR::Filter<juce::dsp::IIR::Coefficients<float>>`
- **Purpose:** Per-region lowpass filtering with resonance
- **Parameters Affected:** `region_N_filter_cutoff`, `region_N_filter_resonance` (per region)
- **Configuration:**
  - Type: 12 dB/octave lowpass (2-pole)
  - Cutoff range: 20 Hz to 20 kHz (logarithmic skew 0.3)
  - Resonance: 0-100% mapped to Q factor (0.5 to 10.0)
  - Coefficients updated in audio thread (no allocations)

### AD Envelope
- **JUCE Class:** Custom implementation (simple linear envelope)
- **Purpose:** Shape amplitude of region playback
- **Parameters Affected:** `region_N_attack`, `region_N_decay` (per region)
- **Configuration:**
  - Attack: 0-1000 ms (linear)
  - Decay: 0-5000 ms (linear)
  - No sustain or release (AD only, as specified)
  - Applied per-sample in processBlock

### Pan Processor
- **JUCE Class:** `juce::dsp::Panner<float>` or custom implementation
- **Purpose:** Stereo panning for each region
- **Parameters Affected:** `region_N_pan` (per region, -100% to +100%)
- **Configuration:**
  - Pan law: Equal-power (constant power panning)
  - -100% = Full Left, 0% = Center, +100% = Full Right
  - Applied after filter and envelope

### Sequencer Engine
- **JUCE Class:** Custom implementation (step sequencer logic)
- **Purpose:** Sequence through 8 steps, each referencing a region
- **Parameters Affected:** `step_1_region` through `step_8_region`, `playback_mode`, `loop_mode`, `crossfade_time`
- **Configuration:**
  - 8 steps, each can reference Region 1-5 or None
  - Playback modes: Sequential (0), Random (1), Custom (2)
  - Loop mode: When enabled, sequence repeats until note-off
  - Step timing: Triggered by MIDI note-on, advances based on tempo (host-driven or internal)

### Crossfade Mixer
- **JUCE Class:** Custom implementation (amplitude crossfading)
- **Purpose:** Smooth transitions between regions during sequencer steps
- **Parameters Affected:** `crossfade_time` (0-500 ms)
- **Configuration:**
  - Equal-power crossfade (prevents amplitude dips)
  - Crossfade duration: 0-500 ms (linear)
  - Applied when transitioning between sequencer steps
  - Formula: `gain_outgoing = sqrt(1.0 - fadePosition)`, `gain_incoming = sqrt(fadePosition)`

### Master Gain
- **JUCE Class:** Simple multiplication (or `juce::dsp::Gain<float>`)
- **Purpose:** Master output volume control
- **Parameters Affected:** `volume` (global, -60.0 to 0.0 dB)
- **Configuration:**
  - Linear dB to amplitude conversion: `amplitude = 10^(dB / 20.0)`
  - Applied to final mixed output

---

## Processing Chain

```
MIDI Note-On
  ↓
Sequencer Engine (determines active region)
  ↓
Region Playback Engine (reads sample region)
  ↓
Pitch Shifter (applies pitch shift)
  ↓
AD Envelope (shapes amplitude)
  ↓
Lowpass Filter (applies filtering)
  ↓
Pan Processor (stereo positioning)
  ↓
Crossfade Mixer (blends with previous region if transitioning)
  ↓
Master Gain (applies volume)
  ↓
Output
```

**Routing notes:**
- All 5 regions process independently (parallel voices)
- Sequencer selects which region(s) are active per step
- Crossfade mixer blends outgoing and incoming regions during step transitions
- Speed parameter affects playback rate globally (all regions)

---

## System Architecture

### File I/O System

**File types supported:** .wav, .aiff, .mp3 (via system codecs)

**Loading strategy:** Background thread loading with atomic flag communication
- File loading triggered by UI drag-drop (message thread)
- Background thread loads via `juce::AudioFormatReader`
- Loaded sample stored in `juce::AudioBuffer<float>` (stereo or mono)
- Audio thread reads from pre-loaded buffer (no locks)

**JUCE classes:**
- `juce::File` - File path management
- `juce::AudioFormatManager` - Format detection and reading
- `juce::AudioFormatReader` - Audio file reading
- `juce::AudioBuffer<float>` - Sample storage

**Thread safety:**
- File I/O operations run on background thread via `Thread::launch()`
- Communication with audio thread via `std::atomic<bool>` ready flag
- Audio thread never blocks on file operations
- Double-buffering: Load to temp buffer, atomic swap when ready

**Error handling:**
- Missing files: Show error in UI, keep previous sample loaded
- Invalid formats: Show error, request different file
- Read failures: Show error, plugin continues with empty sample (silent)

### MIDI Routing

**Input handling:** Omni mode (responds to all MIDI channels)

**Note mapping:**
- MIDI note-on triggers sequencer from step 1
- Velocity: Not used (no velocity sensitivity per spec)
- Note-off: Stops playback (or continues based on envelope decay)
- All MIDI notes trigger same behavior (no note mapping)

**JUCE classes:**
- `juce::MidiBuffer` - MIDI event storage
- `juce::MidiMessage` - Individual MIDI message parsing

**Processing:**
- MIDI messages processed in `processBlock()` on audio thread
- Note-on triggers: Sequencer reset to step 1, start playback
- Note-off handling: Stop sequencer (or let envelope decay naturally)
- CC handling: None (all control via APVTS parameters)

### State Persistence

**What state is saved:**
- APVTS parameters: All 53 parameters (automatic via APVTS)
- Custom state:
  - Loaded sample file path
  - Sample buffer data (or reference to file)
  - Currently active sequencer step (for resume)

**Serialization format:**
- APVTS parameters: Automatic via `AudioProcessorValueTreeState` (XML)
- Custom state: ValueTree with structure:
  ```
  <PluginState>
    <Sample filePath="/path/to/sample.wav"/>
    <Sequencer currentStep="3"/>
  </PluginState>
  ```

**JUCE classes:**
- `juce::AudioProcessorValueTreeState` - Parameter persistence (automatic)
- `juce::ValueTree` - Custom state tree
- `juce::XmlElement` - XML serialization

**Restore behavior:**
- Sample file doesn't exist: Show warning, plugin silent until new sample loaded
- Invalid data: Use defaults (empty sequencer, no sample)
- Version migration: Handle gracefully (ignore unknown fields)

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| speed | Float | 0.5-2.0x | Region Playback Engine | Playback rate multiplier (affects tempo + pitch) |
| volume | Float | -60.0 to 0.0 dB | Master Gain | Output volume |
| region_N_start | Float | 0-100% | Region Playback Engine | Region start position in sample |
| region_N_end | Float | 0-100% | Region Playback Engine | Region end position in sample |
| region_N_pitch | Float | -24 to +24 st | Pitch Shifter | Pitch shift amount |
| region_N_filter_cutoff | Float | 20-20000 Hz | Lowpass Filter | Cutoff frequency (log skew 0.3) |
| region_N_filter_resonance | Float | 0-100% | Lowpass Filter | Resonance/Q factor |
| region_N_attack | Float | 0-1000 ms | AD Envelope | Attack time |
| region_N_decay | Float | 0-5000 ms | AD Envelope | Decay time |
| region_N_pan | Float | -100 to +100% | Pan Processor | Stereo pan position |
| step_N_region | Choice | None/1-5 | Sequencer Engine | Region assignment for step N |
| playback_mode | Choice | Sequential/Random/Custom | Sequencer Engine | Playback mode |
| loop_mode | Bool | On/Off | Sequencer Engine | Loop enable |
| crossfade_time | Float | 0-500 ms | Crossfade Mixer | Transition duration |

---

## Algorithm Details

### Region Playback Engine

**Algorithm:** Variable-rate sample playback with region boundaries

**Implementation notes:**
- Sample position tracking: `float samplePosition` per region
- Playback increment: `increment = playbackRate * (sampleRate / fileSampleRate)`
- Region boundaries: `startSample = (startPercent / 100.0) * totalSamples`
- End handling: When position exceeds `endSample`, stop or loop based on sequencer
- Interpolation: Linear interpolation between samples (acceptable quality)

### Pitch Shifter (Granular Synthesis)

**Algorithm:** Granular synthesis with overlapping grains

**Implementation notes:**
- Grain size: 1024 samples (~21ms @ 48kHz)
- Overlap: 50% (512 samples)
- Grain spacing: `grainSpacing = grainSize / pitchRatio`
- Window function: Hann window for smooth grain boundaries
- Buffer management: Circular buffer for grain storage
- Pitch ratio: `ratio = 2^(pitchSemitones / 12.0)`

**Alternative approach:** If granular proves insufficient quality:
- Phase vocoder (higher quality, higher CPU)
- `juce::dsp::PitchShifter` if available in JUCE 8

### AD Envelope

**Algorithm:** Linear amplitude envelope

**Implementation notes:**
- State: `enum { Attack, Decay, Idle }`
- Attack phase: `amplitude = time / attackTime` (0 to 1.0)
- Decay phase: `amplitude = 1.0 - ((time - attackTime) / decayTime)` (1.0 to 0.0)
- Time tracking: `float envelopeTime` per region
- Reset: On sequencer step change or note-on

### Crossfade Mixer

**Algorithm:** Equal-power crossfade

**Implementation notes:**
- Fade position: `float fadePosition` (0.0 to 1.0)
- Outgoing gain: `sqrt(1.0 - fadePosition)`
- Incoming gain: `sqrt(fadePosition)`
- Duration: `crossfadeTime` in samples = `(crossfadeTimeMs / 1000.0) * sampleRate`
- Applied during step transitions only

---

## Integration Points

### Feature Dependencies

- Sample loading → Region playback: Must load sample before playback
- Sequencer → Region playback: Sequencer selects which region plays
- Pitch shifter → Region playback: Pitch shift applied to region audio
- AD envelope → Region playback: Envelope shapes region amplitude
- Filter → AD envelope: Filter applied after envelope (or before? - design decision)
- Pan → Filter: Pan applied after filtering
- Crossfade mixer → Sequencer: Crossfade triggered by sequencer step changes
- Master gain → All regions: Final output gain

### Parameter Interactions

- Speed parameter affects all regions equally (global playback rate)
- Region start/end boundaries must be validated (start < end)
- Crossfade time affects transition smoothness (longer = smoother but slower)
- Loop mode + envelope decay: If loop enabled, envelope may not complete decay

### Processing Order Requirements

**Per-sample processing order (REQUIRED):**

1. **MIDI input processing:** Check for note-on/note-off, update sequencer
2. **Sequencer step update:** Advance step if needed, determine active region
3. **Region playback:** Read sample data at current position
4. **Pitch shifting:** Apply pitch shift via granular synthesis
5. **AD envelope:** Apply amplitude shaping
6. **Lowpass filter:** Apply filtering
7. **Pan processing:** Apply stereo panning
8. **Crossfade mixing:** Blend with previous region if transitioning
9. **Master gain:** Apply volume
10. **Output:** Write to output buffer

**Parallel processing:**
- All 5 regions can process independently (if multiple active)
- Sequencer determines which region(s) are active per step

### Thread Boundaries

**Audio thread:**
- All DSP processing (playback, pitch shift, filter, envelope, pan, crossfade)
- Parameter reads via `APVTS::getRawParameterValue()->load()` (atomic)
- Sample buffer reads (pre-loaded, no locks)
- MIDI message processing

**Message thread:**
- Parameter updates from UI via APVTS (atomic writes)
- Sample file loading trigger (launches background thread)
- UI repaints
- Preset loading/saving

**Background thread:**
- Sample file loading via `AudioFormatReader` (can take seconds for large files)
- File format detection
- Sample buffer allocation and population

**Communication:**
- Sample loading: `std::atomic<bool>` ready flag + atomic pointer swap
- Parameters: APVTS atomic reads/writes
- No mutexes in audio thread

---

## Implementation Risks

### Pitch Shifting (Granular Synthesis)

**Complexity:** MEDIUM-HIGH

**Risk Level:** MEDIUM

**Risk factors:**
1. Granular synthesis requires careful buffer management
2. Quality may be lower than phase vocoder (graininess artifacts)
3. CPU cost: ~20-30% single core estimated
4. Latency: ~10-20ms (grain size dependent)

**Alternative approaches:**
1. **Phase vocoder:**
   - Complexity: HIGH
   - Quality: Highest (minimal artifacts)
   - CPU: ~40-60% single core
   - Latency: ~40ms (FFT size dependent)
   - Best for: Maximum quality

2. **Simple time-stretching:**
   - Complexity: LOW
   - Quality: Lowest (obvious artifacts)
   - CPU: ~5% single core
   - Best for: Prototyping only

**Fallback architecture:**
- **Primary:** Granular synthesis (good quality/performance balance)
- **Fallback 1:** If granular quality unacceptable → Phase vocoder (higher CPU)
- **Fallback 2:** If both fail → Simple time-stretching (reduced scope)

**Mitigation strategy:**
1. Start with granular synthesis prototype
2. Test quality with various pitch shifts (-24 to +24 semitones)
3. Benchmark CPU usage early
4. Consider JUCE's built-in pitch shifter if available

### Sample Loading (File I/O)

**Complexity:** MEDIUM

**Risk Level:** LOW-MEDIUM

**Risk factors:**
1. Large files may take seconds to load (UI blocking risk)
2. Thread safety: Must avoid audio thread blocking
3. Memory usage: Full sample in memory (large files = high RAM)

**Alternative approaches:**
1. **Streaming:**
   - Complexity: HIGH
   - Memory: Lower (load chunks as needed)
   - Implementation: More complex buffer management
   - Best for: Very large files (>100MB)

2. **Lazy loading:**
   - Complexity: MEDIUM
   - Memory: Lower (load on first use)
   - Implementation: Requires state tracking
   - Best for: Multiple samples (not applicable here)

**Fallback architecture:**
- **Primary:** Full sample in memory (simplest, acceptable for typical sample sizes)
- **Fallback:** If memory issues → Streaming (for very large files)

**Mitigation strategy:**
1. Use background thread loading (non-blocking)
2. Show progress indicator for large files
3. Limit file size warning (>50MB)
4. Test with various file formats and sizes

### Sequencer Timing

**Complexity:** MEDIUM

**Risk Level:** MEDIUM

**Risk factors:**
1. Step timing: Host tempo vs. internal timing
2. Crossfade timing: Must align with step changes
3. Loop behavior: When to restart sequence

**Alternative approaches:**
1. **Host tempo sync:**
   - Complexity: MEDIUM
   - Benefit: Syncs with DAW tempo
   - Implementation: Read host tempo, calculate step duration

2. **Internal timing:**
   - Complexity: LOW
   - Benefit: Independent of host
   - Implementation: Fixed step duration

**Fallback architecture:**
- **Primary:** Host tempo sync (more professional)
- **Fallback:** If host tempo unavailable → Internal timing (fixed duration)

**Mitigation strategy:**
1. Research JUCE host tempo access (`getPlayHead()`)
2. Test with multiple DAWs (tempo sync behavior)
3. Document timing behavior in user manual

### Overall Project Risk

**Overall complexity:** HIGH
- Pitch shifting (MEDIUM-HIGH) + Sample loading (MEDIUM) + Sequencer (MEDIUM) + 5 parallel regions
- Multiple complex features with interdependencies

**Highest risk component:** Pitch Shifting
- Represents ~40% of project risk
- Algorithmically complex
- Quality vs. performance tradeoff
- May require fallback approach

**Recommended approach:**
1. **Phase 1 - Foundation:** Sample loading + basic playback (LOW risk)
2. **Phase 2 - Core DSP:** Filter, envelope, pan (MEDIUM risk)
3. **Phase 3 - Pitch shifting:** Granular synthesis prototype (MEDIUM-HIGH risk)
4. **Phase 4 - Sequencer:** Step sequencing + crossfade (MEDIUM risk)
5. **Phase 5 - Integration:** All features together + optimization

---

## Architecture Decisions

### Pitch Shifting Algorithm Choice

**Decision:** Use granular synthesis (not phase vocoder) for pitch shifting

**Rationale:**
- Good quality/performance balance (~20-30% CPU vs ~40-60% for phase vocoder)
- Lower latency (~10-20ms vs ~40ms)
- Simpler implementation than phase vocoder
- Acceptable quality for most use cases

**Alternatives considered:**
1. **Phase vocoder:**
   - Why rejected: Higher CPU cost, higher latency, more complex
   - When to reconsider: If granular quality proves insufficient

2. **Simple time-stretching:**
   - Why rejected: Too low quality, obvious artifacts
   - When to reconsider: Prototyping only

**Tradeoffs accepted:**
- **Lower quality than phase vocoder:** Acceptable for most use cases
- **Graininess artifacts:** May be audible at extreme pitch shifts
- **When to revisit:** If user feedback indicates quality issues

### Sample Loading Strategy

**Decision:** Load entire sample into memory (not streaming)

**Rationale:**
- Simplest implementation
- Acceptable for typical sample sizes (<50MB)
- No complex buffer management
- Random access to any region (required for sequencer)

**Alternatives considered:**
1. **Streaming:**
   - Why rejected: More complex, not needed for typical sizes
   - When to reconsider: If users need very large files (>100MB)

**Tradeoffs accepted:**
- **Higher memory usage:** Acceptable for typical samples
- **Longer load time for large files:** Mitigated with background loading + progress indicator

### Sequencer Timing

**Decision:** Use host tempo sync (not internal timing)

**Rationale:**
- More professional behavior
- Syncs with DAW tempo
- Standard for sequencer plugins

**Alternatives considered:**
1. **Internal timing:**
   - Why rejected: Less professional, doesn't sync with DAW
   - When to reconsider: If host tempo unavailable

**Tradeoffs accepted:**
- **Dependency on host tempo:** Fallback to internal timing if unavailable

---

## Special Considerations

### Thread Safety
- All parameter reads use atomic `getRawParameterValue()->load()`
- Sample buffer: Atomic pointer swap on load (double-buffering)
- No mutexes in audio thread
- Background thread never touches audio buffers in use

### Performance
- Pitch shifting: ~20-30% CPU (most expensive component)
- Filter: ~5% CPU per region (5 regions = ~25% total)
- Total estimated: ~50-60% single core at 48kHz with all regions active
- Optimization: Only process active regions (sequencer determines)

### Denormal Protection
- Use `juce::ScopedNoDenormals` in processBlock()
- All JUCE DSP components handle denormals internally
- Custom envelope uses phase wrapping to avoid denormals

### Sample Rate Handling
- Sample rate conversion: If file sample rate ≠ host rate, resample on load
- Pitch shifter grain size: Fixed in samples (adjusts with sample rate)
- Filter coefficients: Recalculated in prepareToPlay() with new sample rate
- Envelope timing: Converted from ms to samples in prepareToPlay()

### Latency
- Pitch shifting: ~10-20ms (grain size dependent)
- Filter: Minimal (<1ms)
- Total: ~10-20ms (report via getLatencySamples() for host compensation)

---

## Research References

### Professional Plugins

1. **Spectres (Slate+Ash)**
   - Multi-sample triggering approach
   - Creative sound design workflow
   - Observed: Region-based sample manipulation

2. **Native Instruments Kontakt**
   - Multi-region sampler
   - Pitch shifting via granular synthesis
   - Observed: High-quality granular implementation

3. **Ableton Simpler**
   - Region-based sample playback
   - Pitch shifting with time-stretching
   - Observed: Simple but effective approach

### JUCE Documentation

- **juce::AudioFormatManager**: Format detection and reading
- **juce::AudioFormatReader**: Audio file reading
- **juce::dsp::IIR::Filter**: Biquad filter with coefficient helpers
- **juce::dsp::Panner**: Stereo panning (if available)
- **juce::AudioBuffer<float>**: Sample storage

### Technical Resources

- DAFX (Digital Audio Effects) - Granular synthesis chapter
- Designing Audio Effect Plugins in C++ (Will Pirkle) - Sample playback patterns
- JUCE Tutorial: Audio Format Manager

---

## Notes

- Chose granular synthesis over phase vocoder for better performance/quality balance
- Decided against streaming for simplicity (acceptable for typical sample sizes)
- Filter order: Applied after envelope (design decision - could be before)
- Crossfade uses equal-power to prevent amplitude dips
- Sequencer timing: Host tempo sync preferred, internal timing fallback

