# DSP Architecture: DrumRoulette

**CRITICAL CONTRACT:** This specification is immutable during Stages 2-5 implementation. Stage 1 Planning cannot proceed without this file. Stage 4 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research
**Referenced by:** Stage 1 (Planning), Stage 4 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Voice Architecture (8 Independent Voices)
- **JUCE Class:** `juce::Synthesiser` + `juce::SynthesiserVoice` subclass
- **Purpose:** Manage 8 independent sample playback voices with polyphony and MIDI note routing
- **Parameters Affected:** All per-slot parameters (VOLUME, DECAY, ATTACK, TILT_FILTER, PITCH, SOLO, MUTE)
- **Configuration:**
  - 8 voices minimum (one per slot)
  - MIDI note mapping: C1 (36) → Slot 1, C#1 (37) → Slot 2, ..., G1 (43) → Slot 8
  - Voice stealing: None (8 discrete slots, no polyphony per slot)
  - Each voice maintains independent state (sample, envelope, filter)

### Sample Playback Engine
- **JUCE Class:** `juce::AudioFormatManager` + `juce::AudioFormatReader` + `AudioSampleBuffer`
- **Purpose:** Load and play audio samples with pitch shifting and velocity sensitivity
- **Parameters Affected:** FOLDER_PATH, RANDOMIZE, PITCH
- **Configuration:**
  - Supported formats: WAV, AIFF, MP3, AAC (via AudioFormatManager registration)
  - Playback method: Read sample into AudioSampleBuffer at load time
  - Pitch shifting: Variable playback rate using Linear interpolation
  - Pitch formula: `playbackRate = pow(2.0, semitones / 12.0)` where semitones ∈ [-12, +12]
  - Velocity handling: MIDI velocity (0-127) scales volume linearly (0.0-1.0)

### Envelope Generator (Per-Voice ADSR)
- **JUCE Class:** `juce::ADSR`
- **Purpose:** Shape sample playback with percussive envelope (sustain always 0)
- **Parameters Affected:** ATTACK, DECAY
- **Configuration:**
  - Attack: 0-50ms (user parameter)
  - Decay: 10ms-2s (user parameter)
  - Sustain: 0.0 (fixed, not exposed to user - decay-focused design)
  - Release: 50ms (fixed, for note-off smoothing)
  - Envelope triggers on MIDI note-on, releases on note-off or when decay completes

### Tilt Filter (Per-Voice)
- **JUCE Class:** `juce::dsp::IIR::Filter<float>` (first-order shelving filters)
- **Purpose:** Brightness/darkness control with pivot at 1kHz
- **Parameters Affected:** TILT_FILTER
- **Configuration:**
  - Range: -12dB to +12dB
  - Implementation: Cascaded low-shelf (below 1kHz) + high-shelf (above 1kHz)
  - Low-shelf: Cuts/boosts below 1kHz by TILT_FILTER value
  - High-shelf: Boosts/cuts above 1kHz by TILT_FILTER value (opposite polarity)
  - At 0dB: Flat response (unity gain)
  - At +12dB: Brighter (high boost, low cut)
  - At -12dB: Darker (low boost, high cut)

### Folder-Based Randomization
- **JUCE Class:** Custom implementation using `juce::File` + `juce::Random`
- **Purpose:** Randomly select audio files from user-specified folders
- **Parameters Affected:** FOLDER_PATH, RANDOMIZE, LOCK
- **Configuration:**
  - Recursive folder scanning (includes subfolders)
  - File filtering: Only audio formats (WAV, AIFF, MP3, AAC)
  - True random selection: `Random::getSystemRandom().nextInt(Range<int>(0, fileCount))`
  - Global randomize: Randomize all slots where LOCK = false
  - Error handling: Display error if folder empty or contains no valid audio files
  - No state persistence: Folder paths stored with project, but samples not saved

### Multi-Output Routing
- **JUCE Class:** `juce::AudioProcessor::getBusesLayout()` configuration
- **Purpose:** Route each slot to individual stereo output for DAW mixing
- **Parameters Affected:** None (automatic routing)
- **Configuration:**
  - Bus 0 (Main): Stereo output for all slots mixed together
  - Bus 1-8 (Individual): Stereo outputs for Slot 1-8 respectively
  - Total outputs: 18 channels (2 main + 16 individual)
  - Routing: Each voice always outputs to both main mix AND its individual output
  - Solo/Mute logic: Affects main mix only, individual outputs always active

### Solo/Mute Logic
- **JUCE Class:** Custom implementation in `processBlock()`
- **Purpose:** Enable per-channel soloing and muting for main mix output
- **Parameters Affected:** SOLO, MUTE
- **Configuration:**
  - MUTE: When true, slot contributes 0.0 to main mix (individual output unaffected)
  - SOLO: If ANY slot has SOLO=true, only soloed slots contribute to main mix
  - Priority: SOLO overrides MUTE (if slot is soloed, MUTE is ignored)
  - Individual outputs: Always active regardless of SOLO/MUTE state

### Volume Control (Per-Voice)
- **JUCE Class:** `juce::dsp::Gain<float>`
- **Purpose:** Per-channel level control with fader-style range
- **Parameters Affected:** VOLUME
- **Configuration:**
  - Range: -∞ to +6dB
  - Default: 0dB (unity gain)
  - Conversion: `gain = Decibels::decibelsToGain(volumeDb, -100.0f)` (silence at minimum)
  - Applied after envelope and filter processing

---

## Processing Chain

Per-Voice Signal Flow (8 identical chains):

```
MIDI Note-On (C1-G1) → Voice Allocator
  ↓
Load Sample from Folder (if RANDOMIZE triggered)
  ↓
Sample Playback Engine
  ├─ Pitch Shift (±12 semitones)
  ├─ Velocity Scaling
  └─ ADSR Envelope (ATTACK, DECAY, sustain=0)
  ↓
Tilt Filter (±12dB pivot at 1kHz)
  ↓
Volume Control (-∞ to +6dB)
  ↓
  ├─ Main Mix Bus → SOLO/MUTE Logic → Main Output (Bus 0)
  └─ Individual Bus → Individual Output (Bus 1-8, bypass SOLO/MUTE)
```

**Routing notes:**
- Each voice outputs to TWO destinations simultaneously:
  1. Main mix bus (subject to SOLO/MUTE)
  2. Individual stereo output (always active)
- Global RANDOMIZE button triggers randomization for all slots where LOCK=false
- Per-slot RANDOMIZE button replaces current sample immediately (even during playback)
- Envelope state persists until decay completes, even if new note triggered

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| FOLDER_PATH_1..8 | String | File path | Folder Randomization | Directory path for sample selection |
| RANDOMIZE_1..8 | Button | Trigger | Folder Randomization | Pick random file from assigned folder |
| LOCK_1..8 | Bool | 0/1 | Folder Randomization | Exclude slot from global randomization |
| VOLUME_1..8 | Float | -∞ to +6dB | Volume Control | Channel level (decibels) |
| DECAY_1..8 | Float | 10ms-2s | Envelope Generator | ADSR decay time (sustain=0) |
| ATTACK_1..8 | Float | 0-50ms | Envelope Generator | ADSR attack time |
| TILT_FILTER_1..8 | Float | -12 to +12dB | Tilt Filter | Brightness control (pivot 1kHz) |
| PITCH_1..8 | Float | -12 to +12 semitones | Sample Playback | Pitch shift amount |
| SOLO_1..8 | Bool | 0/1 | Solo/Mute Logic | Solo this channel |
| MUTE_1..8 | Bool | 0/1 | Solo/Mute Logic | Mute this channel |
| RANDOMIZE_ALL | Button | Trigger | Folder Randomization | Randomize all unlocked slots |

**Total:** 73 parameters (8 slots × 9 parameters each, + 1 global button)

---

## Algorithm Details

### Sample Playback with Pitch Shifting

**Algorithm:** Variable-rate sample playback using fractional indexing

**Implementation notes:**
- Pitch ratio formula: `playbackRate = pow(2.0, pitchSemitones / 12.0)`
- Fractional sample position: `currentPosition += playbackRate` (float increment)
- Interpolation: Linear interpolation between adjacent samples
  - `sample = (1-frac) * buffer[floor(pos)] + frac * buffer[floor(pos)+1]`
  - where `frac = currentPosition - floor(currentPosition)`
- Boundary handling: Stop playback when `currentPosition >= sampleLength`
- No time-stretching: Pitch shift affects duration (standard sampler behavior)

### Tilt Filter (Shelving EQ Pair)

**Algorithm:** First-order low-shelf + high-shelf filters with opposite polarity

**Implementation notes:**
- Pivot frequency: 1000 Hz (fixed)
- Low-shelf coefficients: `IIR::Coefficients::makeLowShelf(sampleRate, 1000.0, 0.707, tiltGain)`
- High-shelf coefficients: `IIR::Coefficients::makeHighShelf(sampleRate, 1000.0, 0.707, 1.0 / tiltGain)`
  - Note: High-shelf uses inverse gain to create opposite polarity
- Gain conversion: `tiltGain = Decibels::decibelsToGain(tiltDb)`
- Q factor: 0.707 (fixed, moderate slope)
- Recalculate coefficients when TILT_FILTER changes or sample rate changes

### ADSR Envelope with Fixed Sustain

**Algorithm:** Standard ADSR envelope with sustain level forced to 0.0

**Implementation notes:**
- JUCE ADSR parameters:
  ```cpp
  ADSR::Parameters params;
  params.attack = attackMs / 1000.0f;   // Convert ms to seconds
  params.decay = decayMs / 1000.0f;     // Convert ms to seconds
  params.sustain = 0.0f;                // Fixed at 0 (decay-focused)
  params.release = 0.05f;               // 50ms (fixed, for smoothing)
  ```
- Envelope application: `outputSample *= envelope.getNextSample()`
- Note-off behavior: Immediate release (50ms fade to prevent clicks)
- Envelope state check: Use `isActive()` to stop voice rendering when envelope silent

### Folder Randomization with Recursive Scanning

**Algorithm:** Depth-first recursive file scanning with random selection

**Implementation notes:**
- File discovery:
  ```cpp
  File folder(folderPath);
  Array<File> audioFiles = folder.findChildFiles(
      File::findFiles,
      true,  // recurseIntoSubdirectories
      "*.wav;*.aiff;*.aif;*.mp3;*.m4a"
  );
  ```
- Random selection: `int index = Random::getSystemRandom().nextInt(audioFiles.size())`
- Edge case: If `audioFiles.size() == 0`, display error and keep current sample
- Global randomize: Iterate slots, skip if `LOCK == true`, otherwise randomize
- Thread safety: File operations must happen on message thread, not audio thread

### Solo/Mute Logic

**Algorithm:** Priority-based channel selection for main mix

**Implementation notes:**
- Check if ANY slot has SOLO enabled:
  ```cpp
  bool anySolo = false;
  for (int i = 0; i < 8; ++i)
      if (soloParams[i]->get()) anySolo = true;
  ```
- Per-slot gain multiplier for main mix:
  ```cpp
  float mainMixGain = 1.0f;
  if (muteParams[slot]->get()) mainMixGain = 0.0f;
  if (anySolo && !soloParams[slot]->get()) mainMixGain = 0.0f;
  ```
- Individual outputs: Always use gain 1.0 (ignore SOLO/MUTE)
- Apply `mainMixGain` to voice output before summing to main mix buffer

---

## Special Considerations

### Thread Safety
- All parameter reads use `getRawParameterValue()->load()` for atomic access
- Sample loading: Use `MessageManager::callAsync()` to defer file I/O to message thread
- Voice rendering: Lock-free (no allocations, no file access in `processBlock()`)
- Folder randomization buttons: Trigger async file scan, update sample buffer when ready

### Performance
- Sample playback: ~5% CPU per active voice (linear interpolation, ADSR, filter)
- Total estimated: ~40% single core with 8 voices playing simultaneously
- Optimization: Pre-load samples into AudioSampleBuffer (no disk I/O during playback)
- Optimization: Use FloatVectorOperations for buffer operations where applicable

### Denormal Protection
- Use `juce::ScopedNoDenormals` in `processBlock()`
- ADSR envelope: JUCE handles denormals internally
- Filter state: Add DC blocker if denormals detected in testing
- Volume control: Gain below -60dB treated as silence (no multiplication)

### Sample Rate Handling
- Tilt filter coefficients recalculated in `prepareToPlay()` when sample rate changes
- ADSR: Sample rate set via `setSampleRate()` in `prepareToPlay()`
- Pitch shift playback rate: Independent of sample rate (works with loaded sample's native rate)
- Maximum supported: 192kHz

### Latency
- Zero additional latency (direct sample playback, no look-ahead)
- Filter delay: ~1 sample (first-order IIR, negligible)
- Report `getLatencySamples()` = 0 (no host compensation needed)

### Multi-Output Bus Configuration
- Bus layout setup in `isBusesLayoutSupported()`:
  ```cpp
  // Main output: Bus 0 (stereo)
  // Individual outputs: Bus 1-8 (stereo each)
  // Total: 9 output buses, 18 channels
  ```
- DAW compatibility: Some DAWs may not support 9 output buses (fallback to main only)
- Buffer routing: Use `getBusBuffer(busIndex)` to write to specific output bus

---

## Research References

### Professional Plugins

1. **Native Instruments Battery 4**
   - 54 sample cells with 128 velocity layers per cell
   - Individual outputs: 8 mono + 8 stereo (similar to our 8 stereo individual)
   - Parameters per cell: Volume, tuning, pitch envelope, ADSR, effects loop
   - Observed: Sample-accurate timing, 32-bit internal resolution

2. **FXpansion Geist2**
   - Multi-output routing: Up to 64 channels
   - Pad-based interface with mixer-style controls
   - Per-pad envelope, filter, pitch, volume controls
   - Noted: Separate output for browser previews (useful pattern for folder browsing)

3. **Native Instruments Kontakt**
   - Industry-standard sampler engine
   - Pitch shifting via resampling (time-domain, similar to our approach)
   - Filter types: Including shelving filters for tonal shaping
   - Typical ADSR ranges: Attack 0-50ms, Decay 10ms-5s for percussion

### JUCE Documentation

- **juce::Synthesiser**: Framework for polyphonic synthesizers with voice allocation
  - Tutorial: "Build a Synthesiser" demonstrates voice architecture
  - Voice stealing: Not needed for our fixed 8-voice design

- **juce::AudioFormatManager**: Handles multiple audio file formats
  - Formats: WAV, AIFF (built-in), MP3/AAC (requires format registration)
  - Usage: Create AudioFormatReader, read into AudioSampleBuffer

- **juce::ADSR**: Envelope generator with attack, decay, sustain, release
  - `getNextSample()`: Returns envelope value (0.0-1.0) per sample
  - `noteOn()`, `noteOff()`: Trigger envelope stages
  - Sample rate handling: Set via `setSampleRate()` in prepareToPlay()

- **juce::dsp::IIR::Filter**: Biquad filter with coefficient helpers
  - `makeLowShelf()`, `makeHighShelf()`: First-order shelving filters
  - Tilt filter implementation: Cascade two shelving filters with opposite gains

- **juce::dsp::Gain**: Simple gain processor with decibel conversion
  - `setGainDecibels()`: Set gain in dB
  - `process()`: Apply gain to audio block

### Technical Resources

- **Musicdsp.org**: Tilt equalizer algorithms
  - Simple tilt EQ: Uses cascaded shelving filters (our chosen approach)
  - Alternative: Single second-order shelf with variable Q (more complex)

- **Forum discussions (JUCE Forum)**:
  - Pitch shifting: Resampling with interpolation (Linear or Lagrange3rd)
  - Linear interpolation: Fast, acceptable quality for ±12 semitones
  - Lagrange3rd: Smoother but ~3x CPU cost (not needed for drum samples)

- **Audio EQ Cookbook (RBJ)**:
  - Standard formulas for shelving filter coefficients
  - Q = 0.707 recommended for moderate slope (musical response)

---

## Notes

- Chose linear interpolation over Lagrange3rd for pitch shifting (drum samples tolerate lower quality, CPU savings significant)
- Fixed sustain at 0.0 for decay-focused percussive envelope (matches creative brief vision)
- Tilt filter pivot at 1kHz (balanced between body and brightness for drum samples)
- Individual outputs always active (bypass SOLO/MUTE) to enable advanced DAW routing workflows
- No preset system (user manages sample folders manually, keeps plugin simple)
- MIDI velocity affects volume only (not tone or decay, keeps behavior predictable)
- Global RANDOMIZE respects LOCK state (allows partial randomization workflows)
- Folder paths stored with project but samples not embedded (keeps project files small)
