---
plugin: MicroGlitch
date: 2025-11-06
problem_type: dsp_issue
component: juce_dsp
symptoms:
  - HP/LP filter cutoff parameters update in GUI but audio is unaffected
  - Filters stuck at initial values (20Hz HP, 20kHz LP)
  - Moving filter knobs produces no audible change
root_cause: state_sync
juce_version: 8.0.9
resolution_type: code_fix
severity: moderate
tags: [filter, iir, parameters, apvts, coefficients, processblock]
---

# Troubleshooting: DSP Filters Not Responding to Parameter Changes

## Problem
High-pass and low-pass filter parameters in plugin GUI don't affect the audio output. Moving the HP/LP cutoff knobs has no audible effect on the sound, filters appear to be bypassed or stuck at initial values.

## Environment
- JUCE Version: 8.0.9
- Affected: PluginProcessor.cpp processBlock(), MicroGlitch v1.0.0
- Date: 2025-11-06

## Symptoms
- Filter cutoff parameters update in GUI (sliders move, values change)
- No audible change to filtered audio when adjusting HP or LP cutoff
- Filters work at their initial values (20Hz HP, 20kHz LP) but never update
- No audio dropouts, crashes, or error messages
- Other parameters (grain size, chance, swing) work correctly

## What Didn't Work

**Direct solution:** The problem was identified and fixed on the first attempt through code inspection.

## Solution

Filter coefficients were only calculated once in `prepareToPlay()` and never updated when parameters changed during playback. The fix adds `updateFilterCoefficients()` call inside `processBlock()` before applying filters.

**Code changes:**
```cpp
// PluginProcessor.cpp

// Before (broken):
void MicroGlitchAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    // ... grain processing ...
    processGrains(buffer, buffer.getNumSamples());

    // Apply filters (with stale coefficients)
    juce::dsp::AudioBlock<float> block(buffer);
    juce::dsp::ProcessContextReplacing<float> context(block);

    highPassFilter.process(context);
    lowPassFilter.process(context);

    // ... soft clipping ...
}

// After (fixed):
void MicroGlitchAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    // ... grain processing ...
    processGrains(buffer, buffer.getNumSamples());

    // Update filter coefficients from current parameters
    updateFilterCoefficients();

    // Apply filters (with fresh coefficients)
    juce::dsp::AudioBlock<float> block(buffer);
    juce::dsp::ProcessContextReplacing<float> context(block);

    highPassFilter.process(context);
    lowPassFilter.process(context);

    // ... soft clipping ...
}
```

The existing `updateFilterCoefficients()` method was correct, it just wasn't being called:

```cpp
void MicroGlitchAudioProcessor::updateFilterCoefficients()
{
    auto hpFreq = apvts.getRawParameterValue("hpCutoff")->load();
    auto lpFreq = apvts.getRawParameterValue("lpCutoff")->load();

    *highPassFilter.state = *juce::dsp::IIR::Coefficients<float>::makeHighPass(
        currentSampleRate, hpFreq, 0.707f);

    *lowPassFilter.state = *juce::dsp::IIR::Coefficients<float>::makeLowPass(
        currentSampleRate, lpFreq, 0.707f);
}
```

## Why This Works

**Root cause:** DSP filter coefficients are state that must be recalculated when cutoff frequencies change.

JUCE's `juce::dsp::IIR::Filter` stores filter coefficients in its `state` member. These coefficients are calculated from:
- Sample rate (constant after `prepareToPlay()`)
- Cutoff frequency (changes when user moves slider)
- Q factor (constant at 0.707f for basic filters)

When cutoff parameters change, the coefficients must be regenerated by calling `makeHighPass()` or `makeLowPass()` with the new frequency values.

**Before fix:**
1. `prepareToPlay()` calculates coefficients with initial parameter values (20Hz, 20kHz)
2. User moves slider → parameter updates in APVTS
3. `processBlock()` applies filters with OLD coefficients (still 20Hz, 20kHz)
4. Audio is filtered with wrong frequencies

**After fix:**
1. `prepareToPlay()` calculates initial coefficients
2. User moves slider → parameter updates in APVTS
3. `processBlock()` calls `updateFilterCoefficients()` → reads new values → regenerates coefficients
4. `processBlock()` applies filters with FRESH coefficients
5. Audio is filtered with correct frequencies

**Performance consideration:** Calling `updateFilterCoefficients()` every block is acceptable because:
- It only reads two atomic floats from APVTS (fast)
- Coefficient calculation is lightweight math (no allocations)
- This is standard practice for parameter-driven DSP

Alternative approaches like parameter listeners or smoothing would add complexity without significant benefit for cutoff controls.

## Prevention

**When using juce::dsp filters with parameters:**

1. **Always update coefficients in processBlock()** before calling `filter.process()`
   ```cpp
   updateFilterCoefficients();  // Read params, regenerate coefficients
   filter.process(context);     // Apply filtering
   ```

2. **Don't rely on prepareToPlay() alone** - it only runs on initialization and sample rate changes, not parameter changes

3. **Test filter parameters during development:**
   - Load plugin in DAW with audio playing
   - Move filter cutoff knobs through full range
   - Verify audible change in frequency response
   - Use spectrum analyzer to visualize cutoff changes

4. **Common pattern for all parameter-driven DSP:**
   ```cpp
   void processBlock(AudioBuffer<float>& buffer, MidiBuffer&)
   {
       // 1. Update DSP state from parameters
       updateDSPCoefficients();

       // 2. Process audio with current state
       dspProcessor.process(context);
   }
   ```

5. **Alternative: Parameter smoothing** (for parameters that need ramp changes to avoid clicks)
   ```cpp
   // In header:
   juce::SmoothedValue<float> smoothedCutoff;

   // In prepareToPlay():
   smoothedCutoff.reset(sampleRate, 0.05); // 50ms ramp

   // In processBlock():
   if (smoothedCutoff.isSmoothing())
   {
       for (int sample = 0; sample < numSamples; ++sample)
       {
           auto freq = smoothedCutoff.getNextValue();
           // Update coefficients per-sample if smoothing
       }
   }
   ```
   Note: Filter cutoffs typically don't need smoothing unless changing very rapidly.

## Related Issues
No related issues documented yet.
